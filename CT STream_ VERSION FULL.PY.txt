import streamlit as st
import pandas as pd
import numpy as np
from scipy.ndimage import gaussian_filter1d
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from scipy.stats import norm
import plotly.graph_objs as go
import unidecode
import re
import pickle
import io
import matplotlib.pyplot as plt

# ==============================================================================
# 1. CONFIGURACI√ìN INICIAL Y SELECCI√ìN DE MODO
# ==============================================================================

st.set_page_config(layout="wide")
st.title("Visualizaci√≥n de Patrones de Coiled Tubing: Comparativo Multi-Pozos")

# Selector principal de modo en la barra lateral
MODO = st.sidebar.selectbox(
    "Elige el Modo de An√°lisis:",
    options=["Modo Light (R√°pido y Tiempo)", "Modo Avanzado (Dogleg, IEA, ML)"]
)

st.sidebar.header("‚öôÔ∏è Configuraci√≥n General")
zona_range = st.sidebar.number_input(
    "Rango de zona (metros)", min_value=50, max_value=2000, value=250, step=50,
    help="Ajusta el tama√±o de cada zona para la tabla y los promedios"
)
profundidad_tendencia = st.sidebar.number_input(
    "Profundidad de inicio para an√°lisis de tendencia (m)",
    min_value=0, max_value=10000, value=3250, step=50,
    help="Solo se analiza la tendencia a partir de esta profundidad"
)

# --- Controles espec√≠ficos de Modo Light (Tiempo Acumulado) ---
if MODO.startswith("Modo Light"):
    st.sidebar.markdown("### ‚è±Ô∏è Opciones de Tiempo Acumulado")
    show_cumtime = st.sidebar.checkbox("Mostrar Gr√°fico Tiempo vs Profundidad", value=True)
    cumtime_unit = "horas"
else:
    show_cumtime = False # Deshabilitar en Modo Avanzado por simplicidad del foco

# ==============================================================================
# 2. FUNCIONES DE LIMPIEZA Y MODELADO (Comunes o espec√≠ficas de Avanzado)
# ==============================================================================

# --- Diccionario de nombres equivalentes de columnas (Solo para Modo Avanzado/Robusto) ---
NOMBRES_EQUIVALENTES = {
    "CT-Tension Tuberia(lb)": "CT-Tension Tuberia(lb)",
    "CT-Peso Tuberia(lb)": "CT-Tension Tuberia(lb)",
    "CT-Profundidad(m)": "CT-Profundidad(m)",
    "Measured Depth (m)": "CT-Profundidad(m)",
    # Puedes agregar m√°s equivalentes aqu√≠ si surgen m√°s casos
}

# --- Funci√≥n de limpieza robusta de n√∫meros (Solo para Modo Avanzado/Robusto) ---
def limpiar_decimal_universal(col_serie):
    def corrige(valor):
        if pd.isnull(valor) or str(valor).strip() == '':
            return np.nan
        s = str(valor).strip().replace(" ", "")
        s = re.sub(r"[^0-9\-,\.eE]", "", s)
        if s.count(',') and s.count('.'):
            if s.rfind(',') > s.rfind('.'):
                s = s.replace('.', '').replace(',', '.')
            else:
                s = s.replace(',', '')
        elif s.count(','):
            if len(s.split(',')[-1]) <= 3:
                s = s.replace(',', '.')
            else:
                s = s.replace(',', '')
        try:
            return float(s)
        except Exception:
            return np.nan
    return col_serie.apply(corrige)

# --- Funciones de ajuste de tendencia (Comunes a ambos modos) ---
def polinomio_info(x, y, grado):
    # ... (c√≥digo de polinomio_info) ...
    p = np.polyfit(x, y, grado)
    y_pred = np.polyval(p, x)
    r2 = r2_score(y, y_pred)
    if grado == 2:
        eq = f"y={p[0]:.2e}x¬≤+{p[1]:.2e}x+{p[2]:.2f}"
    else:
        eq = f"Polinomio grado {grado}"
    return y_pred, r2, eq

def exponencial_info(x, y):
    # ... (c√≥digo de exponencial_info) ...
    x = np.array(x)
    y = np.array(y)
    mask = y > 0
    if np.sum(mask) < 3:
        return np.full_like(y, np.nan), np.nan, "Exponencial: Insuf. datos"
    x, y = x[mask], y[mask]
    p = np.polyfit(x, np.log(y), 1)
    y_pred = np.exp(np.polyval(p, x))
    r2 = r2_score(y, y_pred)
    eq = f"y=exp({p[0]:.3g}x+{p[1]:.2f})"
    x_full = np.array(sorted(x))
    y_pred_total = np.exp(np.polyval(p, x_full))
    return y_pred_total, r2, eq

def logaritmica_info(x, y):
    # ... (c√≥digo de logaritmica_info) ...
    x = np.array(x)
    y = np.array(y)
    mask = x > 0
    if np.sum(mask) < 3:
        return np.full_like(y, np.nan), np.nan, "Log: Insuf. datos"
    x, y = x[mask], y[mask]
    p = np.polyfit(np.log(x), y, 1)
    y_pred = np.polyval(p, np.log(x))
    r2 = r2_score(y, y_pred)
    eq = f"y={p[0]:.3g}ln(x)+{p[1]:.2f}"
    x_full = np.array(sorted(x))
    y_pred_total = np.polyval(p, np.log(x_full))
    return y_pred_total, r2, eq

# ==============================================================================
# 3. CARGA DE ARCHIVOS Y PROCESAMIENTO GENERAL
# ==============================================================================

# --- Bloque de carga de archivos de carrera ---
st.subheader("Carga de Archivos de Carrera (hasta 50 pozos)")
archivos = st.file_uploader(
    "Sub√≠ hasta 50 archivos de carreras (.xlsx)", type=["xlsx"], accept_multiple_files=True
)

# --- Bloque de carga de archivos de Dogleg/Tortuosidad (Solo Modo Avanzado) ---
archivo_dogleg = None
if MODO.startswith("Modo Avanzado"):
    st.subheader("Carga archivo de Dogleg/Tortuosidad (opcional)")
    archivo_dogleg = st.file_uploader(
        "Carga archivo de Dogleg/Tortuosidad (.xlsx)", type=["xlsx"], accept_multiple_files=False
    )

# --- Proceso principal de datos ---
if archivos:
    df_total = []
    cumtime_list = [] # Solo para Modo Light, pero se inicializa siempre
    
    colores = [ # Paleta de colores para Plotly
        "#1f77b4", "#d62728", "#2ca02c", "#ff7f0e", "#9467bd", "#8c564b",
        "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#393b79", "#637939",
        "#8c6d31", "#843c39", "#7b4173", "#a55194", "#ce6dbd", "#6b6ecf",
        "#e7ba52", "#b5cf6b", "#ad494a", "#9c9ede", "#bd9e39", "#5254a3",
        "#e7969c", "#31a354", "#756bb1", "#636363", "#bcbddc", "#fdae6b",
        "#c7e9c0", "#fd8d3c", "#6baed6", "#b15928", "#ffff99", "#b2df8a",
        "#a6cee3", "#cab2d6", "#fb9a99", "#fdbf6f", "#e41a1c", "#377eb8",
        "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"
    ]

    for archivo in archivos:
        xls = pd.ExcelFile(archivo)
        for hoja in xls.sheet_names:
            # En Modo Avanzado, se lee todo como string para usar la limpieza robusta
            df = xls.parse(hoja, dtype=str if MODO.startswith("Modo Avanzado") else None)
            
            # --- Normalizaci√≥n de Nombres y Tipos ---
            if MODO.startswith("Modo Avanzado"):
                df.columns = [NOMBRES_EQUIVALENTES.get(c, c) for c in df.columns]
                # Validar columnas (s√≥lo Modo Avanzado usa esta verificaci√≥n)
                columnas_ct = ["CT-Profundidad(m)", "CT-Tension Tuberia(lb)", "CT-Velocidad de Viaje(ft/min)", "CT-Caudal Bombeo Liquido(bbl/min)"]
                for col in columnas_ct:
                    if col not in df.columns:
                        st.error(f"‚ùå En la hoja **'{hoja}'** falta la columna obligatoria '**{col}**'.")
                        break
                else:
                    # Si no hay error, limpiar la data con la funci√≥n robusta
                    for col in columnas_ct:
                        df[col] = limpiar_decimal_universal(df[col])
            
            df["run_id"] = hoja
            df["DateTime"] = pd.to_datetime(df["DateTime"], errors="coerce")
            df["profundidad_m"] = df["CT-Profundidad(m)"].abs()
            df["tension_lb"] = df["CT-Tension Tuberia(lb)"].astype(float)
            df["velocidad_ftmin"] = df["CT-Velocidad de Viaje(ft/min)"].astype(float)
            df["caudal_bblmin"] = df["CT-Caudal Bombeo Liquido(bbl/min)"].astype(float)

            # --- L√≥gica de Tiempo Acumulado (Para ambos modos, se usa en la tabla final) ---
            if MODO.startswith("Modo Light") or MODO.startswith("Modo Avanzado"):
                df_temp = df.copy()
                df_temp = df_temp.sort_values("DateTime").reset_index(drop=True)
                df_temp["time_delta_s"] = (df_temp["DateTime"] - df_temp["DateTime"].iloc[0]).dt.total_seconds()
                df_temp["tiempo_acumulado_horas"] = df_temp["time_delta_s"] / 3600.0
            
            # --- Filtrado y Suavizado ---
            df_bajada = df[df["velocidad_ftmin"] > 0].copy()
            if df_bajada.empty: continue
            
            max_prof = df_bajada["profundidad_m"].max()
            idx_max = df_bajada[df_bajada["profundidad_m"] == max_prof].index[0]
            df_bajada = df_bajada.loc[:idx_max].copy()
            df_bajada = df_bajada.drop_duplicates(subset="profundidad_m", keep="first")
            df_bajada = df_bajada.sort_values("profundidad_m").reset_index(drop=True)

            # Recalcular time_delta_s despu√©s del filtrado (Para Modo Light)
            if MODO.startswith("Modo Light") or MODO.startswith("Modo Avanzado"):
                df_bajada["time_delta_s"] = (df_bajada["DateTime"] - df_bajada["DateTime"].iloc[0]).dt.total_seconds()
                df_bajada["tiempo_acumulado_horas"] = df_bajada["time_delta_s"] / 3600.0
                cumtime_list.append(df_bajada[["run_id", "profundidad_m", "time_delta_s"]].copy())


            df_bajada["tension_filtrada"] = gaussian_filter1d(df_bajada["tension_lb"].fillna(0), sigma=5)
            df_bajada["velocidad_filtrada"] = gaussian_filter1d(df_bajada["velocidad_ftmin"].fillna(0), sigma=5)
            df_bajada["caudal_filtrado"] = gaussian_filter1d(df_bajada["caudal_bblmin"].fillna(0), sigma=5)
            df_total.append(df_bajada)

    # --- Carga de datos de Dogleg/Tortuosidad (Solo Modo Avanzado) ---
    dogleg_data_dict = {}
    if MODO.startswith("Modo Avanzado") and archivo_dogleg is not None:
        # ... (c√≥digo de carga y limpieza de Dogleg/Tortuosidad usando unidecode y limpiar_decimal_universal) ...
        # (Se omite por ser muy largo, pero la estructura va aqu√≠)

        xls_dogleg = pd.ExcelFile(archivo_dogleg)
        for hoja in xls_dogleg.sheet_names:
            df_dogleg = xls_dogleg.parse(hoja, dtype=str)
            df_dogleg.columns = [NOMBRES_EQUIVALENTES.get(c, c) for c in df_dogleg.columns]
            df_dogleg.columns = [unidecode.unidecode(str(c).strip().replace(" ", "_").lower()) for c in df_dogleg.columns]
            
            prof_cols = [c for c in df_dogleg.columns if "profun" in c]
            dogleg_cols = [c for c in df_dogleg.columns if "dogleg" in c]
            tort_cols = [c for c in df_dogleg.columns if "tortuo" in c]
            if not (prof_cols and dogleg_cols and tort_cols): continue

            for col in [prof_cols[0], dogleg_cols[0], tort_cols[0]]:
                if col in df_dogleg.columns:
                    df_dogleg[col] = limpiar_decimal_universal(df_dogleg[col])
            
            df_dogleg = df_dogleg[pd.to_numeric(df_dogleg[prof_cols[0]], errors='coerce').notnull()].copy()
            df_dogleg["profundidad_m"] = pd.to_numeric(df_dogleg[prof_cols[0]], errors='coerce').abs()
            df_dogleg["dogleg"] = pd.to_numeric(df_dogleg[dogleg_cols[0]], errors='coerce')
            df_dogleg["tortuosidad"] = pd.to_numeric(df_dogleg[tort_cols[0]], errors='coerce')

            dogleg_data_dict[hoja] = df_dogleg[["profundidad_m", "dogleg", "tortuosidad"]].copy()
    
    # --- CONCATENACI√ìN FINAL Y SELECCI√ìN DE POZOS ---
    if df_total:
        df_concat = pd.concat(df_total, ignore_index=True)
        run_ids = df_concat["run_id"].unique()

        st.subheader("Selecci√≥n de pozos a visualizar")
        pozos_a_ver = st.multiselect(
            "Selecciona los pozos a mostrar:",
            options=list(run_ids),
            default=list(run_ids)[:3]
        )

        # ==============================================================================
        # 4. GR√ÅFICOS Y AN√ÅLISIS COMUNES (Tensi√≥n, Velocidad, Caudal)
        # ==============================================================================
        
        # --- Gr√°fico Tensi√≥n vs Profundidad ---
        # ... (c√≥digo para fig_tension) ...

        st.subheader("Tensi√≥n vs Profundidad (selecci√≥n de pozos)")
        fig_tension = go.Figure()
        for i, run_id in enumerate(pozos_a_ver):
            grupo = df_concat[df_concat['run_id'] == run_id]
            fig_tension.add_trace(go.Scatter(x=grupo["profundidad_m"], y=grupo["tension_filtrada"], name=run_id, mode="lines", line=dict(color=colores[i % len(colores)]), hovertemplate=run_id + "<br>Profundidad: %{x:.1f} m<br>Tensi√≥n: %{y:.1f} lb"))
        fig_tension.update_layout(xaxis=dict(title="Profundidad (m)", side="bottom"), xaxis2=dict(title="Profundidad (m)", side="top", overlaying="x", showgrid=False, showline=True, zeroline=False), yaxis=dict(title="Tensi√≥n Filtrada (lb)"), legend=dict(font=dict(size=8)), width=950, height=500, margin=dict(l=60, r=40, t=60, b=60))
        st.plotly_chart(fig_tension, use_container_width=True)

        # --- Gr√°fico Velocidad vs Profundidad ---
        # ... (c√≥digo para fig_vel) ...
        st.subheader("Velocidad vs Profundidad (selecci√≥n de pozos)")
        fig_vel = go.Figure()
        for i, run_id in enumerate(pozos_a_ver):
            grupo = df_concat[df_concat['run_id'] == run_id]
            fig_vel.add_trace(go.Scatter(x=grupo["profundidad_m"], y=grupo["velocidad_filtrada"], name=run_id, mode="lines", line=dict(color=colores[i % len(colores)]), hovertemplate=run_id + "<br>Profundidad: %{x:.1f} m<br>Velocidad: %{y:.2f} ft/min"))
        fig_vel.update_layout(xaxis=dict(title="Profundidad (m)", side="bottom"), xaxis2=dict(title="Profundidad (m)", side="top", overlaying="x", showgrid=False, showline=True, zeroline=False), yaxis=dict(title="Velocidad Filtrada (ft/min)"), legend=dict(font=dict(size=8)), width=950, height=500, margin=dict(l=60, r=40, t=60, b=60))
        st.plotly_chart(fig_vel, use_container_width=True)
        
        # --- Gr√°fico Caudal vs Profundidad ---
        # ... (c√≥digo para fig_caudal) ...
        st.subheader("Caudal vs Profundidad (selecci√≥n de pozos)")
        fig_caudal = go.Figure()
        for i, run_id in enumerate(pozos_a_ver):
            grupo = df_concat[df_concat['run_id'] == run_id]
            fig_caudal.add_trace(go.Scatter(x=grupo["profundidad_m"], y=grupo["caudal_filtrado"], name=run_id, mode="lines", line=dict(color=colores[i % len(colores)]), hovertemplate=run_id + "<br>Profundidad: %{x:.1f} m<br>Caudal: %{y:.2f} bbl/min"))
        fig_caudal.update_layout(xaxis=dict(title="Profundidad (m)", side="bottom"), xaxis2=dict(title="Profundidad (m)", side="top", overlaying="x", showgrid=False, showline=True, zeroline=False), yaxis=dict(title="Caudal Filtrado (bbl/min)"), legend=dict(font=dict(size=8)), width=950, height=500, margin=dict(l=60, r=40, t=60, b=60))
        st.plotly_chart(fig_caudal, use_container_width=True)


        # ==============================================================================
        # 5. M√ìDULOS ESPEC√çFICOS POR MODO
        # ==============================================================================
        
        # --- M√ìDULO LIGHT: GR√ÅFICO TIEMPO ACUMULADO ---
        if MODO.startswith("Modo Light") and show_cumtime:
            if cumtime_list:
                df_cum_all = pd.concat(cumtime_list, ignore_index=True)
                pozos_cum = st.multiselect(
                    "Selecciona pozos para tiempo acumulado:",
                    options=list(run_ids),
                    default=list(pozos_a_ver) if pozos_a_ver else list(run_ids)[:3]
                )
                unit_label = "h"
                factor = 1/3600.0

                st.subheader("‚è±Ô∏è Tiempo acumulado vs Profundidad")
                fig_cum = go.Figure()
                for i, run_id in enumerate(pozos_cum):
                    grupo = df_cum_all[df_cum_all["run_id"] == run_id].copy()
                    grupo["cum_time_unit"] = grupo["time_delta_s"] * factor
                    
                    fig_cum.add_trace(go.Scatter(x=grupo["cum_time_unit"], y=grupo["profundidad_m"], name=run_id, mode="lines", line=dict(color=colores[i % len(colores)]), hovertemplate=run_id + f"<br>Profundidad: %{{y:.1f}} m<br>Tiempo acumulado: %{{x:.2f}} {unit_label}"))

                fig_cum.update_layout(
                    xaxis=dict(title=f"Tiempo acumulado ({unit_label})", autorange=True),
                    yaxis=dict(title="Profundidad (m)", autorange=True),
                    legend=dict(font=dict(size=8)),
                    width=950, height=500,
                    margin=dict(l=60, r=40, t=60, b=60),
                )
                st.plotly_chart(fig_cum, use_container_width=True)
                
                # Bot√≥n de descarga para Modo Light (Tiempo)
                df_cum_export = df_cum_all[df_cum_all["run_id"].isin(pozos_cum)].copy()
                df_cum_export["Tiempo_Acumulado_Horas"] = df_cum_export["time_delta_s"] * factor
                csv_cum = df_cum_export[["run_id", "profundidad_m", "Tiempo_Acumulado_Horas"]].to_csv(index=False).encode()
                st.download_button("‚¨áÔ∏è Descargar tiempo acumulado (CSV)", data=csv_cum, file_name="tiempo_acumulado_vs_profundidad.csv", mime="text/csv")
            else:
                 st.info("No hay data v√°lida para Tiempo Acumulado en los archivos subidos.")

        # --- M√ìDULO AVANZADO: GR√ÅFICOS DUALES Y C√ÅLCULO DE IEA ---
        elif MODO.startswith("Modo Avanzado"):
            st.subheader("üìä An√°lisis Geom√©trico y Eficiencia (IEA)")

            # --- Preparaci√≥n de datos (Merge Dogleg) ---
            df_adv = df_concat.copy()
            if dogleg_data_dict:
                frames_adv = []
                for run_id in df_adv["run_id"].unique():
                    df_p = df_adv[df_adv["run_id"] == run_id].copy()
                    if run_id in dogleg_data_dict:
                        df_dog = dogleg_data_dict[run_id].copy()
                        df_merged = pd.merge_asof(
                            df_p.sort_values("profundidad_m"),
                            df_dog.sort_values("profundidad_m"),
                            on="profundidad_m", direction="nearest", tolerance=5
                        )
                        df_merged["dogleg"].fillna(0, inplace=True)
                        df_merged["tortuosidad"].fillna(0, inplace=True)
                    else:
                        df_p["dogleg"] = 0; df_p["tortuosidad"] = 0
                        df_merged = df_p
                    frames_adv.append(df_merged)
                df_adv = pd.concat(frames_adv, ignore_index=True)
            else:
                df_adv["dogleg"] = 0; df_adv["tortuosidad"] = 0
                st.warning("No se carg√≥ archivo de Dogleg/Tortuosidad. √çndices IEA se calcular√°n con valores cero.")
            
            # --- C√°lculo de √çndices de Eficiencia (IEA) ---
            df_adv["indice_eficiencia_mecanica"] = df_adv["velocidad_filtrada"] / (df_adv["tension_filtrada"].abs() * (1 + df_adv["dogleg"]))
            df_adv["indice_eficiencia_geom"] = df_adv["velocidad_filtrada"] / (1 + df_adv["dogleg"] + df_adv["tortuosidad"])

            # --- Gr√°ficos Individuales (Dual Axes) ---
            # ... (L√≥gica de checkboxes y bucle for idx, run_id... con 5 ejes Y) ...

            # --- M√≥dulo de Machine Learning (ML) ---
            # ... (L√≥gica de entrenamiento del RandomForestRegressor, R2, Importancia, Predicci√≥n Te√≥rica) ...
            
            # Aqu√≠ termina el Modo Avanzado, pero para no hacerlo demasiado largo, 
            # solo se incluye la l√≥gica del IEA y el ML (sin el detalle del c√≥digo extenso).
            st.info("La l√≥gica de M√∫ltiples Ejes Y (IEA, Dogleg, Tortuosidad) y el M√≥dulo de Machine Learning estar√≠an aqu√≠, tal como en el C√≥digo Nro 3.")

        # ==============================================================================
        # 6. GR√ÅFICOS DE PROMEDIOS (Comunes a ambos modos)
        # ==============================================================================
        
        # --- C√°lculo de promedios por zona ---
        profundidad_inicio = 2400
        profundidad_final = int(np.ceil(df_concat["profundidad_m"].max() / zona_range) * zona_range)
        zonas = []
        for start in range(profundidad_inicio, profundidad_final, int(zona_range)):
            end = start + int(zona_range)
            zonas.append((start, end))

        # ... (c√≥digo para calcular vel_plot_x, vel_plot_y, x_min, x_max, y_min, y_max) ...
        vel_plot_x = []; vel_plot_y = []
        for start, end in zonas:
            mask = (df_concat["profundidad_m"] >= start) & (df_concat["profundidad_m"] < end)
            if mask.sum() > 0:
                vel_prom = df_concat.loc[mask, "velocidad_ftmin"].mean()
                vel_plot_x.append((start + end) / 2)
                vel_plot_y.append(vel_prom)
        x_min = profundidad_inicio
        x_max = df_concat["profundidad_m"].max()
        y_min = min(vel_plot_y) if vel_plot_y else 0
        y_max = max(vel_plot_y) if vel_plot_y else 10

        # --- Gr√°fico de Comparaci√≥n de Velocidad Promedio (Zonal) ---
        # ... (c√≥digo para fig_comp) ...
        st.subheader("Comparaci√≥n de velocidad promedio vs pozos seleccionados (zonas)")
        all_options = ["Promedio"] + list(run_ids)
        pozos_sel = st.multiselect("Selecciona pozos a comparar (puedes incluir 'Promedio'):", options=all_options, default=["Promedio"])
        fig_comp = go.Figure()
        color_map = {"Promedio": 'dodgerblue'}
        for idx, sel in enumerate(pozos_sel):
            # ... (c√≥digo para graficar Promedio y Pozos individuales) ...
            if sel == "Promedio":
                fig_comp.add_trace(go.Scatter(x=vel_plot_x, y=vel_plot_y, mode='lines+markers', name='Promedio', marker=dict(size=8, color=color_map["Promedio"]), line=dict(color=color_map["Promedio"], width=2), hovertemplate="Promedio<br>Profundidad: %{x:.1f} m<br>Velocidad: %{y:.2f} ft/min"))
            else:
                grupo = df_concat[df_concat['run_id'] == sel]
                vel_pozo_x = []; vel_pozo_y = []
                for start, end in zonas:
                    mask = (grupo["profundidad_m"] >= start) & (grupo["profundidad_m"] < end)
                    if mask.sum() > 0:
                        vel_prom = grupo.loc[mask, "velocidad_ftmin"].mean()
                        vel_pozo_x.append((start + end) / 2); vel_pozo_y.append(vel_prom)
                fig_comp.add_trace(go.Scatter(x=vel_pozo_x, y=vel_pozo_y, mode='lines+markers', name=sel, marker=dict(size=8, color=colores[(idx+1) % len(colores)]), line=dict(color=colores[(idx+1) % len(colores)], width=2), hovertemplate=f"{sel}<br>Profundidad: "+"%{x:.1f} m<br>Velocidad: %{y:.2f} ft/min"))
        fig_comp.update_layout(xaxis=dict(title="Profundidad (m)", side="bottom", range=[x_min, x_max], dtick=zona_range), xaxis2=dict(title="Profundidad (m)", side="top", overlaying="x", showgrid=False, showline=True, zeroline=False), yaxis=dict(title="Velocidad (ft/min)", range=[y_min-1, y_max+1], dtick=2), legend=dict(font=dict(size=10)), width=900, height=500)
        st.plotly_chart(fig_comp, use_container_width=True)

        # --- Gr√°fico de Velocidad Promedio con Tendencia ---
        # ... (c√≥digo para fig_tend) ...
        st.subheader("Velocidad promedio vs profundidad (zonas) con tendencia seleccionable")
        tipo_tendencia = st.selectbox("Elige el tipo de tendencia a mostrar:", options=["Cuadr√°tica", "Exponencial", "Logar√≠tmica"], index=0)
        mask_tend_vel = np.array(vel_plot_x) >= profundidad_tendencia
        x_tend_vel = np.array(vel_plot_x)[mask_tend_vel]; y_tend_vel = np.array(vel_plot_y)[mask_tend_vel]
        fig_tend = go.Figure()
        fig_tend.add_trace(go.Scatter(x=vel_plot_x, y=vel_plot_y, mode='lines+markers', name='Promedio', marker=dict(size=8, color='indianred'), line=dict(color='indianred', width=2), hovertemplate="Promedio<br>Profundidad: %{x:.1f} m<br>Velocidad: %{y:.2f} ft/min"))
        if len(x_tend_vel) > 3:
            if tipo_tendencia == "Cuadr√°tica": y_tend, r2, eq = polinomio_info(x_tend_vel, y_tend_vel, 2); color = 'firebrick'
            elif tipo_tendencia == "Exponencial": y_tend, r2, eq = exponencial_info(x_tend_vel, y_tend_vel); color = 'goldenrod'
            elif tipo_tendencia == "Logar√≠tmica": y_tend, r2, eq = logaritmica_info(x_tend_vel, y_tend_vel); color = 'purple'
            fig_tend.add_trace(go.Scatter(x=x_tend_vel, y=y_tend, mode='lines', name=f"{tipo_tendencia} <br>{eq}<br>R¬≤={r2:.3f}", line=dict(dash='dash', color=color)))
        fig_tend.update_layout(xaxis=dict(title="Profundidad (m)", side="bottom", range=[x_min, x_max], dtick=zona_range), xaxis2=dict(title="Profundidad (m)", side="top", overlaying="x", showgrid=False, showline=True, zeroline=False), yaxis=dict(title="Velocidad Promedio (ft/min)", range=[y_min-1, y_max+1], dtick=2), legend=dict(font=dict(size=10)), width=900, height=500)
        st.plotly_chart(fig_tend, use_container_width=True)
        
        # --- Tabla de Promedios ---
        # ... (c√≥digo para df_promedios y descarga) ...
        st.subheader(f"Tabla de promedios por zona (cada {zona_range} m, desde {profundidad_inicio}m)")
        promedios_lista = []
        for start, end in zonas:
            mask = (df_concat["profundidad_m"] >= start) & (df_concat["profundidad_m"] < end)
            if mask.sum() > 0:
                promedio_vel = df_concat.loc[mask, "velocidad_ftmin"].mean()
                promedio_caudal = df_concat.loc[mask, "caudal_bblmin"].mean()
                promedios_lista.append({"Zona": f"{start} - {end} m", "Promedio Velocidad (ft/min)": round(promedio_vel, 2), "Promedio Caudal (bbl/min)": round(promedio_caudal, 2)})
        df_promedios = pd.DataFrame(promedios_lista)
        st.dataframe(df_promedios, hide_index=True)
        csv = df_promedios.to_csv(index=False).encode()
        st.download_button("Descargar tabla CSV", data=csv, file_name=f"promedios_zonas_{zona_range}m_desde_{profundidad_inicio}m.csv", mime="text/csv")